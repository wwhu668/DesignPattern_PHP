# DesignPattern_PHP## PHP 基础设计模式学习，默认自动加载类因为边幅，所以将方法左边 `{` 不做换行处理### 单例模式> 一个类只允许实例化一次：如数据库类```php<?phpclass Database{    private $instance;    private function __construct(){}    public static function getInstance()    {        if(empty(self::$instance)) {            self::$instance = new self();        }        return self::$instance;    }}```---### 工厂模式> 对一个类实现统一实例化```php<?phpclass Factory{    public static function createDatabase()    {        $obj = Database::getInstance();// new Database();        return $obj;    }}```---### 注册器模式> 将对象存入数组```php<?phpclass Register{    private static $objects;    public static function set($alias, $object)    {        self::$objects[$alias] = $object;    }    public static function get($alias)    {        if(!isset($objects[$alias])) {            return null;        }        return $objects[$alias];    }    public static function remove($alias)    {        unset($objects[$alias]);    }}```### 适配器模式> 可以将不同的接口封装成统一的API,如:mysql,mysqli,pdo```php<?phpinstance Database{    public function construct(Array $config);    public function query($sql);    public function close();}class Mysqli implements Database{    public function construct($cofig)    {        extract($config);        $this->conn = mysqli_connect($host, $user, $passwd, $dbname);    }    public function query($sql)    {        // ...    }    public function close()    {        // ...    }}class PDO implements PDO{    public function construct($config)    {        extract($config);        $this->conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd);    }    public function query($sql)    {        // ...    }    public function close()    {        // ...    }}```---### 策略模式> 将一组特定的行为或算法封装成类，以适应某些上下文环境```php<?phpinterface Strategy{    public function title();    public function content();}class PostNoe implements Strategy{    public function title()    {        echo '文章1的标题';    }    public function content()    {        echo '文章1的内容';    }}class PostTwo implements Strategy{    public function title()     {        echo '文章2的标题';    }    public function content()     {        echo '文章2的内容';    }}class Post{    private $strategy;    public function show()    {        $this->strategy->title();        $this->strategy->content();    }    public function setStrategy(Strategy $strategy)    {        $this->strategy = $strategy;    }}$post = new Post();$post->setStrategy(new PostTwo);$post->show();```---### 观察者模式> 当一个对象状态发生改变时，依赖他的对象全部会收到通知，并自动更新```php<?php# 观察者，当事件发生者(事件触发),观察者自动更新 updateclass Logic1 implements SplObserver{    public function update(SplSubject $subject)    {        echo 'Logic1\n';    }}class Logic2 implements SplObserver{    public function update(SplSubject $subject)    {        echo 'Logic2\n';    }}# 事件发生者abstract Event implements SplSubject{    // 观察者对象集合    private $observers;    // 添加观察者    public function attach(SplObserver $observer)    {        $this->observers[] = $observer;    }    public function detach(SplObserver $observer)    {        if($index = array_search($observer, $this->observers)) {            unset($this->observers[$index]);        }    }    // 通知    public function notify()    {        // 遍历观察者对象，逐一执行 观察者 update        foreach($this->observers as $observer) {            $observer->update($this);        }    }}class EventTrigger extends Event{    // 事件发生    public function trigger()    {        echo 'event trigger';        // 通知        $this->notify();    }}```---### 装饰器> 扩展一个类一般可以使用继承或者组合的形式。使用继承的方式扩展时，随着基类子类的增多，以及子类的子类出现，继而出现了代码的无限制膨胀，增加了系统的复杂性。而使用装饰者模式既继承又引用，能动态扩展类的一些功能，减少了继承数量。```php<?php
#代码实例（出自php设计模式）interface Component{    public function operation();}/** * 装饰角色 */class Decorator implements Component{    protected $component;    public function __construct(Component $component)    {        $this->component = $component;    }    public function operation()    {        $this->component->operation();    }}/** * 具体装饰类A */class ConcreteDecoratorA extends Decorator{    public function __construct(Component $component)    {        parent::__construct($component);    }    public function operation()    {        parent::operation();        $this->addedOperationA();//新添加的操作    }    public function addedOperationA()    {        echo 'Add Operation A <br />';    }}/** * 具体装饰类B */class ConcreteDecoratorB extends Decorator{    public function __construct(Component $component)    {        parent::__construct($component);    }    public function operation()    {        parent::operation();        $this->addedOperationB();//新添加的操作    }    public function addedOperationB()    {        echo 'Add Operation B <br />';    }}/** * 具体构件 */class ConcreteComponent implements Component{    public function operation()    {        echo 'Concrete Component operation <br />';    }}/** * 客户端 */class Client{    public static function main()    {        $component = new ConcreteComponent();        $decoratorA = new ConcreteDecoratorA($component);        $decoratorB = new ConcreteDecoratorB($decoratorA);        $decoratorA->operation();        $decoratorB->operation();    }}Client::main();// 输出// Concrete Component operation <br />// Add Operation A <br />//// Concrete Component operation <br />// Add Operation A <br />// Add Operation B <br />```---### 迭代器> 迭代器模式提供一种访问一个容器对象中的各个元素，而又不暴露其内部细节的方法。```php<?phpclass TestIterator implements Iterator{    private $data;    private $index;    private $count;    public function __construct($data)    {        $this->data = $data;        $this->index = 0;        $this->count = count($this->data);    }    public function rewind()    {        echo __METHOD__;        $this->index = 0;    }    public function valid()    {        echo __METHOD__;        return $this->index < $this->count;    }    public function key()    {        echo __METHOD__;        return $this->index;    }    public function current()    {        echo __METHOD__;        $row = $this->data[$this->index];        $row['ip'] = gethostbyname($row['url']);        return $row;    }    public function next() {        echo __METHOD__;        $this->index ++;    }}$array = array(	array('url' => 'www.zeroplace.cn'),	array('url' => 'www.baidu.com'),);$d = new TestIterator($array);foreach($d as $k => $v) {    echo '---------------';    echo $v['url'] . '===' . $v['ip'];    echo '###############';}// TestIterator::rewind// TestIterator::valid// TestIterator::current// TestIterator::key// ---------------// www.zeroplace.cn// ###############// TestIterator::next// TestIterator::valid// TestIterator::current// TestIterator::key// ---------------// www.baidu.com// ###############// TestIterator::next// TestIterator::valid```